= Evo Engine
Michael Kelly <michaelkelly322@gmail.com>
:source-highlighter: coderay


== Project Setup
I'm going to assume some knowledge of basic CMake or C++ project structure and pick a solid starting point for our project. The CMake configuration for this project has 2 basic artifacts, `libevoengine.so` and the executable `evo` that is linked with it.  Building the initial project follows the standard cmake method:

1. `cd build`
2. `cmake ..`
3. `make`

To run the program, while still in `build/` just execute `./evo`.

.Initial project directory structure
[source]
----
├── build/
├── engine/
│   ├── include
│   │   ├── evo.h
│   │   └── logger.h
│   ├── src/
│   │   └── logger.cpp
│   └── CMakeLists.txt
├── CMakeLists.txt
├── evo.cpp
└── README.asciidoc
----

In this program, `evo.cpp` is our `main` entrypoint and it includes `engine/include/evo.h` that acts as a single point of inclusion for all engine header files.  Right now, `evo.cpp` just outputs some text and waits for the user to press the enter key to exit. Output is sent to the console using the `Evo::Logger` class defined in `engine/include/logger.h`.

We'll use this structure as a starting point for building out the engine design.

== Entrypoint

=== Why take main

=== Abstracting an application
